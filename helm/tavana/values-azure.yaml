# Tavana Helm Chart - Azure Values Template
# Cloud-Agnostic Auto-Scaling DuckDB Query Platform
#
# Usage:
#   helm install tavana ./helm/tavana -f values-azure.yaml \
#     --set global.imageRegistry=YOUR_ACR.azurecr.io \
#     --set ingress.hosts[0].host=tavana.example.com

# Global settings
global:
  namespace: tavana
  # Container registry - Override with your ACR at deploy time:
  #   helm install tavana ./helm/tavana -f values-azure.yaml \
  #     --set global.imageRegistry=YOUR_ACR.azurecr.io \
  #     --set global.imageTag=1.0.73
  # 
  # NOTE: Many enterprise AKS clusters block external registries (GHCR, Docker Hub)
  # due to firewall rules. Always use your private ACR in those cases.
  imageRegistry: ""  # REQUIRED: Set via --set global.imageRegistry=YOUR_ACR.azurecr.io
  imagePullPolicy: Always
  imageTag: ""       # REQUIRED: Set via --set global.imageTag=VERSION

# Private registry credentials (optional for Docker Hub public, required for ACR)
imagePullSecrets: []
  # - name: acr-secret

# ═══════════════════════════════════════════════════════════════════════════════
# GATEWAY CONFIGURATION
# ═══════════════════════════════════════════════════════════════════════════════
gateway:
  enabled: true
  replicaCount: 2
  image:
    repository: tavana-gateway
  
  service:
    type: ClusterIP
    pgPort: 15432
    httpPort: 8080
  
  # Resource sizing for D4s_v3 nodes (4 vCPU, 16 GB)
  resources:
    requests:
      memory: "1Gi"
      cpu: "500m"
    limits:
      memory: "4Gi"
      cpu: "2000m"

# ═══════════════════════════════════════════════════════════════════════════════
# WORKER CONFIGURATION (Query Execution)
# ═══════════════════════════════════════════════════════════════════════════════
worker:
  enabled: true
  replicaCount: 2
  minReplicas: 2
  maxReplicas: 8
  image:
    repository: tavana-worker
  
  # Resource sizing optimized by VPA
  # Smaller limits allow more workers = better parallelism
  # VPA will adjust based on actual usage
  resources:
    requests:
      memory: "2Gi"       # VPA recommendation
      cpu: "250m"         # VPA recommendation
    limits:
      memory: "4Gi"       # Allow bursting to 4Gi
      cpu: "2"            # 2 cores max per worker

# ═══════════════════════════════════════════════════════════════════════════════
# AUTOSCALING (HPA)
# ═══════════════════════════════════════════════════════════════════════════════
hpa:
  enabled: true
  minReplicas: 2
  maxReplicas: 8           # Max 8 workers (fits 4 nodes)
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 75

# ═══════════════════════════════════════════════════════════════════════════════
# OBJECT STORAGE (Azure Blob / ADLS Gen2)
# ═══════════════════════════════════════════════════════════════════════════════
objectStorage:
  # Leave empty to use Workload Identity with Azure SDK
  endpoint: ""
  bucket: ""
  region: "westeurope"
  pathStyle: false
  existingSecret: ""

# ═══════════════════════════════════════════════════════════════════════════════
# IDENTITY & SECURITY
# ═══════════════════════════════════════════════════════════════════════════════
serviceAccount:
  create: true
  name: "tavana"
  annotations:
    # Azure Workload Identity
    azure.workload.identity/client-id: ""

podLabels:
  azure.workload.identity/use: "true"

# Pod Security (Azure Policy compliant)
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

containerSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

# ═══════════════════════════════════════════════════════════════════════════════
# NETWORKING
# ═══════════════════════════════════════════════════════════════════════════════
networkPolicies:
  enabled: true
  egressCIDRs:
    - 10.0.0.0/8
    - 100.64.0.0/10
    - 168.63.0.0/16

# Ingress via Azure Application Gateway
ingress:
  enabled: true
  className: "azure/application-gateway"
  annotations:
    appgw.ingress.kubernetes.io/ssl-redirect: "true"
    appgw.ingress.kubernetes.io/connection-draining: "true"
    appgw.ingress.kubernetes.io/request-timeout: "300"
    appgw.ingress.kubernetes.io/backend-protocol: "http"
    appgw.ingress.kubernetes.io/health-probe-path: "/health"
  hosts:
    - host: ""  # REQUIRED
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: tavana-tls
      hosts:
        - ""  # REQUIRED

# ═══════════════════════════════════════════════════════════════════════════════
# OBSERVABILITY
# ═══════════════════════════════════════════════════════════════════════════════
monitoring:
  prometheus:
    enabled: false

config:
  logLevel: "info"

rbac:
  create: true

podDisruptionBudget:
  gateway:
    enabled: true
    minAvailable: 1
  worker:
    enabled: true
    maxUnavailable: 1
